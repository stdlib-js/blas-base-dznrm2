{
  "version": 3,
  "sources": ["../lib/ndarray.js", "../lib/dznrm2.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar FLOAT64_MAX = require( '@stdlib/constants-float64-max' );\nvar abs = require( '@stdlib/math-base-special-abs' );\nvar abs2 = require( '@stdlib/math-base-special-abs2' );\nvar sqrt = require( '@stdlib/math-base-special-sqrt' );\nvar reinterpret = require( '@stdlib/strided-base-reinterpret-complex128' );\n\n\n// VARIABLES //\n\n// Blue's scaling constants:\nvar tsml = 1.4916681462400413E-154;\nvar tbig = 1.9979190722022350E+146;\nvar ssml = 4.4989137945431964E+161;\nvar sbig = 1.1113793747425387E-162;\n\n\n// MAIN //\n\n/**\n* Computes the L2-norm of a complex double-precision floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - input array\n* @param {integer} strideX - `zx` stride length\n* @param {NonNegativeInteger} offsetX - starting index for `zx`\n* @returns {number} L2-norm\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n*\n* var zx = new Complex128Array( [ 0.3, 0.1, 0.5, 0.0, 0.0, 0.5, 0.0, 0.2, 2.0, 3.0 ] );\n*\n* var norm = dznrm2( 4, zx, 1, 0 );\n* // returns ~0.8\n*/\nfunction dznrm2( N, zx, strideX, offsetX ) {\n\tvar notbig;\n\tvar sumsq;\n\tvar viewX;\n\tvar abig;\n\tvar amed;\n\tvar asml;\n\tvar ymax;\n\tvar ymin;\n\tvar scl;\n\tvar ax;\n\tvar ix;\n\tvar sx;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn 0.0;\n\t}\n\t// Reinterpret the input array as a real-valued array comprised of interleaved real and imaginary components:\n\tviewX = reinterpret( zx, 0 );\n\tsx = strideX * 2;\n\tix = offsetX * 2;\n\n\t// Initialize loop values for accumulation:\n\tnotbig = true;\n\n\tsumsq = 0.0;\n\tabig = 0.0;\n\tamed = 0.0;\n\tasml = 0.0;\n\tscl = 1.0;\n\n\t// Compute the sum of squares using 3 accumulators--`abig` (sum of squares scaled down to avoid overflow), `asml` (sum of squares scaled up to avoid underflow), `amed` (sum of squares that do not require scaling)--and thresholds and multipliers--`tbig` (values bigger than this are scaled down by `sbig`) and `tsml` (values smaller than this are scaled up by `ssml`)...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tax = abs( viewX[ ix ] );\n\t\tif ( ax > tbig ) {\n\t\t\tabig += abs2( ax * sbig );\n\t\t\tnotbig = false;\n\t\t} else if ( ax < tsml ) {\n\t\t\tif ( notbig ) {\n\t\t\t\tasml += abs2( ax * ssml );\n\t\t\t}\n\t\t} else {\n\t\t\tamed += ax * ax;\n\t\t}\n\t\tax = abs( viewX[ ix + 1 ] );\n\t\tif ( ax > tbig ) {\n\t\t\tabig += abs2( ax * sbig );\n\t\t\tnotbig = false;\n\t\t} else if ( ax < tsml ) {\n\t\t\tif ( notbig ) {\n\t\t\t\tasml += abs2( ax * ssml );\n\t\t\t}\n\t\t} else {\n\t\t\tamed += ax * ax;\n\t\t}\n\t\tix += sx;\n\t}\n\t// Combine `abig` and `amed` or `amed` and `asml` if more than one accumulator was used...\n\tif ( abig > 0.0 ) {\n\t\t// Combine `abig` and `amed` if `abig` > 0...\n\t\tif ( amed > 0.0 || ( amed > FLOAT64_MAX ) || ( amed !== amed ) ) {\n\t\t\tabig += ( amed * sbig ) * sbig;\n\t\t}\n\t\tscl = 1.0 / sbig;\n\t\tsumsq = abig;\n\t} else if ( asml > 0.0 ) {\n\t\t// Combine `amed` and `asml` if `asml` > 0...\n\t\tif ( amed > 0.0 || amed > FLOAT64_MAX || ( amed !== amed ) ) {\n\t\t\tamed = sqrt( amed );\n\t\t\tasml = sqrt( asml ) / ssml;\n\t\t\tif ( asml > amed ) {\n\t\t\t\tymin = amed;\n\t\t\t\tymax = asml;\n\t\t\t} else {\n\t\t\t\tymin = asml;\n\t\t\t\tymax = amed;\n\t\t\t}\n\t\t\tscl = 1.0;\n\t\t\tsumsq = ( ymax * ymax ) * ( 1.0 + abs2( ymin / ymax ) );\n\t\t} else {\n\t\t\tscl = 1.0 / ssml;\n\t\t\tsumsq = asml;\n\t\t}\n\t} else {\n\t\t// All values are mid-range...\n\t\tscl = 1.0;\n\t\tsumsq = amed;\n\t}\n\treturn sqrt( sumsq ) * scl;\n}\n\n\n// EXPORTS //\n\nmodule.exports = dznrm2;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar stride2offset = require( '@stdlib/strided-base-stride2offset' );\nvar ndarray = require( './ndarray.js' );\n\n\n// MAIN //\n\n/**\n* Computes the L2-norm of a complex double-precision floating-point vector.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} zx - input array\n* @param {integer} strideX - `zx` stride length\n* @returns {number} L2-norm\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n*\n* var zx = new Complex128Array( [ 0.3, 0.1, 0.5, 0.0, 0.0, 0.5, 0.0, 0.2, 2.0, 3.0 ] );\n*\n* var norm = dznrm2( 4, zx, 1 );\n* // returns ~0.8\n*/\nfunction dznrm2( N, zx, strideX ) {\n\treturn ndarray( N, zx, strideX, stride2offset( N, strideX ) );\n}\n\n\n// EXPORTS //\n\nmodule.exports = dznrm2;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar dznrm2 = require( './dznrm2.js' );\nvar ndarray = require( './ndarray.js' );\n\n\n// MAIN //\n\nsetReadOnly( dznrm2, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nmodule.exports = dznrm2;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* BLAS level 1 routine to find the euclidean norm of a complex double-precision floating-point vector.\n*\n* @module @stdlib/blas-base-dznrm2\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var dznrm2 = require( '@stdlib/blas-base-dznrm2' );\n*\n* var zx = new Complex128Array( [ 0.3, 0.1, 0.5, 0.0, 0.0, 0.5, 0.0, 0.2, 2.0, 3.0 ] );\n*\n* var norm = dznrm2( 4, zx, 1 );\n* // returns ~0.8\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var dznrm2 = require( '@stdlib/blas-base-dznrm2' );\n*\n* var zx = new Complex128Array( [ 0.3, 0.1, 0.5, 0.0, 0.0, 0.5, 0.0, 0.2, 2.0, 3.0 ] );\n*\n* var norm = dznrm2.ndarray( 4, zx, 1, 0 );\n* // returns ~0.8\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nvar tryRequire = require( '@stdlib/utils-try-require' );\nvar isError = require( '@stdlib/assert-is-error' );\nvar main = require( './main.js' );\n\n\n// MAIN //\n\nvar dznrm2;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdznrm2 = main;\n} else {\n\tdznrm2 = tmp;\n}\n\n\n// EXPORTS //\n\nmodule.exports = dznrm2;\n\n// exports: { \"ndarray\": \"dznrm2.ndarray\" }\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAc,QAAS,+BAAgC,EACvDC,EAAM,QAAS,+BAAgC,EAC/CC,EAAO,QAAS,gCAAiC,EACjDC,EAAO,QAAS,gCAAiC,EACjDC,EAAc,QAAS,6CAA8C,EAMrEC,EAAO,uBACPC,EAAO,qBACPC,EAAO,sBACPC,EAAO,uBAsBX,SAASC,EAAQC,EAAGC,EAAIC,EAASC,EAAU,CAC1C,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,GAAKhB,GAAK,EACT,MAAO,GAiBR,IAdAM,EAAQZ,EAAaO,EAAI,CAAE,EAC3Bc,EAAKb,EAAU,EACfY,EAAKX,EAAU,EAGfC,EAAS,GAETC,EAAQ,EACRE,EAAO,EACPC,EAAO,EACPC,EAAO,EACPG,EAAM,EAGAI,EAAI,EAAGA,EAAIhB,EAAGgB,IACnBH,EAAKtB,EAAKe,EAAOQ,CAAG,CAAE,EACjBD,EAAKjB,GACTW,GAAQf,EAAMqB,EAAKf,CAAK,EACxBM,EAAS,IACES,EAAKlB,EACXS,IACJK,GAAQjB,EAAMqB,EAAKhB,CAAK,GAGzBW,GAAQK,EAAKA,EAEdA,EAAKtB,EAAKe,EAAOQ,EAAK,CAAE,CAAE,EACrBD,EAAKjB,GACTW,GAAQf,EAAMqB,EAAKf,CAAK,EACxBM,EAAS,IACES,EAAKlB,EACXS,IACJK,GAAQjB,EAAMqB,EAAKhB,CAAK,GAGzBW,GAAQK,EAAKA,EAEdC,GAAMC,EAGP,OAAKR,EAAO,IAENC,EAAO,GAASA,EAAOlB,GAAmBkB,IAASA,KACvDD,GAAUC,EAAOV,EAASA,GAE3Bc,EAAM,EAAMd,EACZO,EAAQE,GACGE,EAAO,EAEbD,EAAO,GAAOA,EAAOlB,GAAiBkB,IAASA,GACnDA,EAAOf,EAAMe,CAAK,EAClBC,EAAOhB,EAAMgB,CAAK,EAAIZ,EACjBY,EAAOD,GACXG,EAAOH,EACPE,EAAOD,IAEPE,EAAOF,EACPC,EAAOF,GAERI,EAAM,EACNP,EAAUK,EAAOA,GAAW,EAAMlB,EAAMmB,EAAOD,CAAK,KAEpDE,EAAM,EAAMf,EACZQ,EAAQI,IAITG,EAAM,EACNP,EAAQG,GAEFf,EAAMY,CAAM,EAAIO,CACxB,CAKAvB,EAAO,QAAUU,ICxJjB,IAAAkB,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAgB,QAAS,oCAAqC,EAC9DC,EAAU,IAqBd,SAASC,EAAQC,EAAGC,EAAIC,EAAU,CACjC,OAAOJ,EAASE,EAAGC,EAAIC,EAASL,EAAeG,EAAGE,CAAQ,CAAE,CAC7D,CAKAN,EAAO,QAAUG,ICnDjB,IAAAI,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAc,QAAS,uDAAwD,EAC/EC,EAAS,IACTC,EAAU,IAKdF,EAAaC,EAAQ,UAAWC,CAAQ,EAKxCH,EAAO,QAAUE,ICYjB,IAAIE,EAAO,QAAS,MAAO,EAAE,KACzBC,EAAa,QAAS,2BAA4B,EAClDC,EAAU,QAAS,yBAA0B,EAC7CC,EAAO,IAKPC,EACAC,EAAMJ,EAAYD,EAAM,UAAW,aAAc,CAAE,EAClDE,EAASG,CAAI,EACjBD,EAASD,EAETC,EAASC,EAMV,OAAO,QAAUD",
  "names": ["require_ndarray", "__commonJSMin", "exports", "module", "FLOAT64_MAX", "abs", "abs2", "sqrt", "reinterpret", "tsml", "tbig", "ssml", "sbig", "dznrm2", "N", "zx", "strideX", "offsetX", "notbig", "sumsq", "viewX", "abig", "amed", "asml", "ymax", "ymin", "scl", "ax", "ix", "sx", "i", "require_dznrm2", "__commonJSMin", "exports", "module", "stride2offset", "ndarray", "dznrm2", "N", "zx", "strideX", "require_main", "__commonJSMin", "exports", "module", "setReadOnly", "dznrm2", "ndarray", "join", "tryRequire", "isError", "main", "dznrm2", "tmp"]
}
